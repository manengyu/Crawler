RSA非对称加密算法.
SHA安全哈希算法,又散列算法.
SHA MD属于摘要算法.

RSA:
公钥用于加密,解密(区别于私钥解密又称验签);
私钥解密,加密(区别于公钥加密又称签名);
实现签名时通常配合摘要算法(由于消息内容过长,非对称算法耗时较长).

PC1发送msg至PC2加密+签名(亦可仅加密或签名,已互交换公钥)
FROM PC1:
PC2公钥(加密)msg>ciphertext
ciphertext摘要算法>摘要
PC1私钥(签名)摘要>signature
send ciphertext+signature
TO PC2:
PC1公钥(验签)signature>摘要
摘要==ciphertext摘要算法
PC2私钥(解密)ciphertext>msg

Crypto库
pip3 install Crypto==1.4.1
pip3 install pycryptodome==3.6.6
Python27\Lib\site-packages下将crypto文件夹改为Crypto
密钥有开始结束标志无需base64解码，解密后要base64编码
sha摘要及base64编码参数都为字节
DES:pyDes==2.0.1

PyJWT==1.6.4
cryptography==2.3
def generate_token(sub):
    import io
    import jwt
    f = io.open(u"../assets/rsa/private.pem")
    key = f.read()
    f.close()
    payload = {
        "sub": sub
    }
    return bytes.decode(jwt.encode(payload, key, algorithm="RS256"))


def decode_base64(headers):
    import base64
    str_encode = headers[u"authorization"].split(u".")[1]
    str_user = bytes.decode(base64.b64decode(str_encode + "=" * (-len(str_encode) % 4))).replace(u"true", u"True")
    return eval(str_user)
decode_base64(request.headers)
 

from Crypto.Hash import SHA
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_v1_5


def add_to_16(value):
    while len(value) % 16 != 0:
        value += '\0'
    return str.encode(value)
    
    
def aesencrypt(raw_data, aes_key):  # aes加密
    BS = AES.block_size  # 加密时使用的key，只能是长度16,24和32的字符串
    padding_size = len(raw_data) if len(raw_data) == len(raw_data.encode()) else len(raw_data.encode())  ＃ 兼容中文
    pad = lambda s: s + (BS - padding_size % BS) * chr(BS - padding_size % BS)
    cipher = AES.new(add_to_16(aes_key), AES.MODE_EAX)  # mod 待验证
    encrypted = cipher.encrypt(pad(raw_data).encode(u"utf-8"))  # aes加密
    result = base64.b64encode(encrypted)  # base64 encode
    return bytes.decode(result)
    #  return bytes.decode(b2a_hex(encrypted))
    
    
def aesdecrypt(en_data, aes_key):  # 把加密的数据，用base64  decode，再用aes解密
    unpad = lambda s: s[0:-ord(s[-1])]
    cipher = AES.new(add_to_16(aes_key), AES.MODE_EAX)  # mod 待验证
    result2 = base64.b64decode(en_data)
    decrypted = unpad(cipher.decrypt(result2).decode())
    return decrypted


def ras_decrypt(privateKey, encrpyt_des):  # 解密des密钥成明文
    from Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5
    rsakey = RSA.importKey(base64.b64decode(privateKey))  # 导入读取到的私钥
    cipher = Cipher_pkcs1_v1_5.new(rsakey)  # 生成对象
    text = cipher.decrypt(base64.b64decode(encrpyt_des), u"ERROR")
    return base64.b64encode(text)


def rsa_sign(privateKey, encrData):  # RSA 签名
    private_keyBytes = base64.b64decode(privateKey)
    priKey = RSA.importKey(private_keyBytes)
    signer = PKCS1_v1_5.new(priKey)
    hash_obj = SHA.new(encrData)  # .encode(u'utf-8')
    signature = base64.b64encode(signer.sign(hash_obj))
    return signature


def rsa_verify(publicKey, signature, encrData):  # RSA 验签
    public_keyBytes = base64.b64decode(publicKey)
    pubKey = RSA.importKey(public_keyBytes)
    h = SHA.new(encrData.encode(u'utf-8'))
    verifier = PKCS1_v1_5.new(pubKey)
    return verifier.verify(h, base64.b64decode(signature))

