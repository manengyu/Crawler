# -*- coding: utf-8 -*-
# 连接数据库
import MySQLdb
import pandas as pd
import logging
def connect_database(db_nick=''):
    conn = ''
    if db_nick == '':
        while True:
            try:
                conn = MySQLdb.connect(host='', user='', passwd='',
                                       db='', port=, charset='utf8')
            except MySQLdb.Error, e:
                print "Mysql Error %d: %s" % (e.args[0], e.args[1])
            if isinstance(conn, MySQLdb.connections.Connection):
                break
    else:
        print 'No such database!!!'
    return conn

def initLogging(logFilename):
    logging.basicConfig(
        level=logging.DEBUG,
        format='LINE %(lineno)-4d  %(levelname)-8s %(message)s',
        datefmt='%m-%d %H:%M',
        filename=logFilename,
        filemode='w')
    # define a Handler which writes INFO messages or higher to the sys.stderr
    console = logging.StreamHandler()
    console.setLevel(logging.DEBUG)
    # set a format which is simpler for console use
    formatter = logging.Formatter('LINE %(lineno)-4d : %(levelname)-8s %(message)s')
    # tell the handler to use this format
    console.setFormatter(formatter)
    logging.getLogger('').addHandler(console)
	
def initlogging(logfilename):  # 将日志文件自动按天、时、分、秒进行分割
    import logging
	logger = logging.getLogger(u"")
	if not logger.handlers:
		formatter = logging.Formatter(u'%(asctime)s %(filename)s [line:%(lineno)d] %(levelname)s %(message)s')
		import logging.handlers
		hdlr = logging.handlers.TimedRotatingFileHandler(logfilename, when=u'D', interval=1, backupCount=30)  # 设置日志分割
		hdlr.setFormatter(formatter)
		logger.addHandler(hdlr)
		logger.setLevel(logging.INFO)
		return logger

if __name__ == "__main__":
    print time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))
    conng = connect_database(db_nick='')
    cur = conn.cursor()
    r = requests.session()
    r.headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0, WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36",
        # "Cookie": get_cookie(),
        'Host': '',
        # 'Referer': '',
        # 'X-Requested-With': 'XMLHttpRequest',
        'Connection': 'keep-alive',
        'Content-Length': '106',
        'Origin': '',
        'Content-Type': 'application/json; charset=UTF-8',  # x-www-form-urlencoded
        'Accept': '*/*',
        # 'Referer': 'h',
        'Accept-Encoding': 'gzip, deflate, br',
        'Accept-Language': 'zh-CN,zh;q=0.8'
    }
    name_url = get_company_url(conn)
    # error_plat = u""  # 默认从第一条运行
    error_plat = u""
    nu = 0
    while len(error_plat):
        time.sleep(1)
        index = list(name_url.get('company_name')).index(error_plat)
        error_plat = get_info(conn, cur, conn_be, cur_be, r, conn_21, cur_21, name_url, index).decode("utf-8")
        nu += 1
        if nu % 9 == 0:  # 重复请求10次无果后停止运行
            break
    cur.close()
    conn.close()
    print "climb finish"
增删改查
cur.execute(insert_sql)
conn_yuqing.commit()
查read_sql()，read_sql_query()只能用于查询
app_management = pd.read_sql(select_sql, conn)


def get_proxies():  # 使用代理ip
    ip = json.loads(requests.get(
        "url").content)
    proxies = {  # 每次请求从代理ip中随机产生一个地址
        "http": "http://username:passwd@" + ip["data"]["proxy_list"][random.randint(0, len(ip) - 1)]
    }
    return proxies

def get_cookie(res):
    cookies = [item[0] + u"=" + item[1] for item in res.cookies.iteritems()]
    return u';'.join(i for i in cookies)

def get_args():
    import sys
    args = []
    for i in range(1, len(sys.argv)+1):
        args[i-1] = sys.argv[i]


def get_args0():
    import argparse
    parser = argparse.ArgumentParser(description=u'manual to this script')
    parser.add_argument(u'-a', type=str, default=None)
    parser.add_argument(u'-b', type=int, default=32)
    args = parser.parse_args()
    print(args.a)
    print(args.b)
python a.py -a 12 -b 33
python a.py -a=12 -b=33

def check_illegal(text):  # 移除非法字符
    illegal = ["v", "-", "x", "y", "%", "\\", "/", "������", "������", "������", "������", "������", "������", "������"]
    for k in illegal:
        if k in text:
            text = text.replace(k, "")
    return text

def handle_time(mtime):  # 处理含今天昨天时间，返回格式化时间
    if "今天" in mtime:
        mtime = time.strftime('%m-%d', time.localtime(time.time())) + mtime.lstrip("今天")
    elif "分钟前" in mtime:
        t = time.time() - int(re.findall("(\d+)", mtime)[0]) * 60
        mtime = time.strftime('%Y-%m-%d %H:%M', time.localtime(t))
    elif "小时前" in mtime:
        t = time.time() - int(re.findall("(\d+)", mtime)[0]) * 60 * 60
        mtime = time.strftime('%Y-%m-%d %H:%M', time.localtime(t))
    elif "昨天" in mtime:
        mtime = time.strftime('%m-%d', time.localtime(time.time()-86400)) + mtime.lstrip("昨天")
    #else:
        #mtime = mtime + ' ' + re.findall('created_at": ".*?(\d{2}:\d{2}:\d{2}).*?",', requests.get(weibo_url).content)[0]
    if len(mtime) < 15:
        mtime = str(datetime.datetime.now().year) + "-" + mtime
    return mtime
	
@staticmethod
    def get_month_start(mon):
        now = datetime.datetime.now()
        today = datetime.date.today()  # 需作调整
        month_start = time.strftime(u'%Y-%m-01', time.localtime(time.time()))
        if mon == u"current":  # 月初
            month_start = unicode(now.year) + u"-" + unicode(now.month) + u"-01"
        elif mon == u"previous":  # 上月初
            month_start = unicode(now.year) + u"-" + unicode(now.month - 1) + u"-01"
        elif mon == u"previous_end":  # 上月末
            month_start = unicode(now.year) + u"-" + unicode(now.month - 1) + u"-" + \
                          unicode(calendar.monthrange(now.year, now.month - 1)[1]) if now.month != 1 else unicode(
                now.year - 1) + u"-12-31"
        elif mon == u"next_day":  # 下一天
            month_start = today + datetime.timedelta(days=1)
        elif mon == u"yesterday":  # 昨天
            month_start = today - datetime.timedelta(days=1)
        elif mon == u"sunday":  # 5天前，周日
            month_start = today - datetime.timedelta(days=5)
        elif mon == u"monday":  # 5天前，周日
            month_start = today - datetime.timedelta(days=4)
        elif mon == u"last_monday":  # 返回上周一零点
            month_start = today - datetime.timedelta(days=7+now.weekday())  # datatime中0为周一
        elif mon == u"this_monday":  # 返回周一零点
            month_start = today - datetime.timedelta(days=now.weekday())  # datatime中0为周一
        return unicode(month_start)
		
def get_today():
    return datetime.date.today()


def get_date(start_date=None, intervals=0, end_date=None):
    start_date = datetime.datetime.strptime(start_date, u'%Y-%m-%d')
    if end_date is not None:
        intervals = (start_date - datetime.datetime.strptime(end_date, u'%Y-%m-%d')).days
    return (start_date + datetime.timedelta(days=intervals)).strftime(u'%Y-%m-%d'), -intervals


def date_cycle(start_date, end_date):
    day_list = []
    start = datetime.datetime.strptime(start_date, u'%Y-%m-%d')
    end = datetime.datetime.strptime(end_date, u'%Y-%m-%d')
    for i in range((end - start).days + 1):
        day = start + datetime.timedelta(days=i)
        day = day.strftime(u"%Y-%m-%d")
        day_list.append(day)
    return day_list


def lastmonth01(date):  # 上个月1号日期
    date = datetime.datetime.strptime(date, u'%Y-%m-%d')
    dayscount = datetime.timedelta(days=date.day)
    dayto = date - dayscount
    date_from = datetime.datetime(dayto.year, dayto.month, 1, 0, 0, 0)
    return date_from.strftime(u'%Y-%m-%d')


def weekend_or_monthend(date=u''):
    # 是否周末
    weekday = datetime.datetime.strptime(date, u'%Y-%m-%d').weekday()
    is_weekend = True if weekday == 6 else False
    # 是否月末
    monthrange = calendar.monthrange(int(date[0:4]), int(date[5:7]))
    monthend = date[0:8] + str(monthrange[1])
    is_monthend = True if monthend == date else False
    return is_weekend, is_monthend

def md5_pwd(pwd):
    import hashlib
    m = hashlib.md5()
    m.update(pwd)
    return m.hexdigest()

def read_file(rootdir):  # 搜索文件夹unicode ur"D:\20170818"
    import os
    import os.path
    search_reault = {}
    for parent, dirnames, filenames in os.walk(rootdir):  # 三个参数：分别返回1.父目录 2.所有文件夹名字（不含路径） 3.所有文件名字
        search_reault[parent] = {'dir': [], 'file': []}
        for dirname in dirnames:  # 文件夹信息
            search_reault[parent]['dir'].append(dirname)
        for filename in filenames:  # 文件信息
            search_reault[parent]['file'].append(filename)
            # os.rename(os.path.join(parent, filename), os.path.join(parent, urllib.unquote(filename.encode('utf-8'))))  # rename
    return search_reault  # {path: {'dir': [], 'file': []},...}
	
import socket
import platform
def get_ip():
    if platform.system() == u'Windows':
        hostname = socket.gethostname()
        inIp = socket.gethostbyname_ex(hostname)[-1][-1]
    else:
        import fcntl
        import struct
        sk = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # outIp = socket.inet_ntoa(fcntl.ioctl(sk.fileno(), 0x8915, struct.pack(u'256s', u"lo"[:15]))[20:24])
        inIp = socket.inet_ntoa(fcntl.ioctl(sk.fileno(), 0x8915, struct.pack(u'256s', u"eth0"[:15]))[20:24])
    return inIp

def random_ipv4():
    return '.'.join(str(randint(0,255)) for _ in range(4))

def random_ipv6():
    return ':'.join(''.join(choice(hexdigits).lower() for _ in range(4)) for _ in range(8))

@staticmethod
def search_platid(conn_140, platname):  # 根据平台名获取指定平台id
	select_sql = u"select platid from yuqing.pre_sourcemsg where platname='" + platname + u"' limit 1"  # 文本待缩减
	platid = pd.read_sql(select_sql, conn_140).get(u"platid")
	return platid[0] if list(platid) else None  # platid不存在，

@staticmethod
def setzero(data):  # None设置为0
	return 0 if data is None else data

@staticmethod
def is_num(data):  # 非数字时设置为0
	return unicode(data) if unicode(data).replace(u".", u"").isdigit() else u"0"

@staticmethod
def check_illegal(text):  # 替换所有非中文为%
	# illegal = [u",", u"，", u" ", u"!", u"！", u"?", u"？"]
	# for k in illegal:
	#     text = text.replace(k, u"%")
	return re.subn(u"[^\u4e00-\u9fa5]", u"%", text)[0]

@staticmethod
def push_json(data):
	return requests.post(u"http://192.168.21.62:5000/yuqing/upt_senti", data=data).text
	
cookie字典转为字符串类型
cookie = [item["name"] + "=" + item["value"] for item in self.r.get_cookies()]
cookiestr = ';'.join(item for item in cookie)

try:  # 网页解码
	if chardet.detect(con)[u"encoding"].upper() in [u"GB2312", u"GBK"]:
		con = con.decode(u"gbk")
	elif chardet.detect(con)[u"encoding"].upper() == u"UTF-8":
		con = con.decode(u"utf-8")
	else:
		con = con.decode(re.findall(u"charset=\"?(.*?)\"",
									con.decode(chardet.detect(con)[u"encoding"]))[0], u"ignore")
	# con = con.decode(u"gbk") if chardet.detect(con)[u"encoding"] == u"GB2312" else \
	#     con.decode(chardet.detect(con)[u"encoding"])
except(UnicodeDecodeError, IndexError):
	con = u""
				
#图片拼接
def image_joint(self, image_list, opt):  # opt= vertical ,horizontal 选择水平显示拼接的图像，或者垂直拼接
	width, height = [], []
	for i in image_list:
		width.append(i.size[0])
		height.append(i.size[1])
	new_img = Image.new(u'RGB', (width[0], sum(height)), 255) if opt == u'vertical' else \
		Image.new(u'RGB', (sum(width), height[0]), 255)
	x = y = count = 0
	for img in image_list:
		new_img.paste(img, (x, y))
		count += 1
		if opt == u'horizontal':
			x += width[count - 1]
		else:
			y += height[count - 1]
	return new_img

# 读取图片url
f = open(u"a.jpg", u"wb")
f.write(reqs.get(image_url).content)
f.close()
captchimage = input(u"image:")

# judge image valid, return if invalid
from io import BytesIO  # py2 from StringIO import StringIO
from PIL import Image
try:
    fp = Image.open(BytesIO(image_bytes))
    fp.colse()
except OSError:
    return ""

web service url需加?WSDL
from requests import Session
from zeep import Client
from zeep.transports import Transport
session = Session()    # 这里是因为url是https，不然不需要transport
session.verify = False
transport = Transport(session=session)
url = ''
client = Client(url, transport=transport)
req = client.service.LoginUserData(LoginName=u"", Password=u"", UniqueId=u"")
mylogin_key = client.service.Login({u"":u"", u"Password":u"", u"UniqueId":u"", u"ShareSuper": False, u"IsAdministrator": False, u"FirstLogin": False})[u""]
print client.service.SingleCheck({u"Name": u"", u"CitizId": u""}, mylogin_key)

def get_nobase64(data):
    import re
    return re.sub(r"[\d\w=+/]{100,}", "hidden", "{}".format(data))
