MongoDB
数据保存在磁盘，经常读取的数据会加载到内存

Redis (http://www.runoob.com/redis/redis-hashes.html)
数据存在内存，可定时向磁盘写入数据,存储分为内存存储、磁盘存储和log文件三部分
基于内存的数据结构服务器
安装：https://github.com/MSOpenTech/redis/releases
win启动与登录
redis-server
redis-cli.exe -h 127.0.0.1 -p 6379 -a password(远端时加密码)
设置键值对SET myKey abc
取出键值对GET myKey
键命令：
命令：DEL/DUMP/EXIST key
设置过期时间EXPIRE key seconds（EXPIREAT key 时间戳），PEXPIRE/PEXPIRE毫秒为单位
移除key过期时间PERSIST key
剩余过期时间TTL key秒为单位（PTTL key毫秒）
MOVE key db
RENAME key newkey
TYPE key(key所储值类型)
字符串命令：
GETRANGE key start end
GETSET key value
GETBIT key offset
MGET key1 [key2,key3,,,]
SETBIT key offset value
SETEX key seconds value(PSETEX以毫秒为单位)
SETNX key value(仅在key不存在时创建)
SETRANGE key offset value
STRLEN key
MSET key1 value1 [key2 value2 ,,,]
MSETNX key1 value1 [key2 value2 ,,,](仅在key不存在时创建)
INCR key(key所存值增1)
INCRBY key increment(key所存值加上指定值)
INCRBYFLOAT key increment(key所存值加浮点型值)
DECR key(key所存值减1)
DECRBY key decrement(key所存值减去指定值)
APPEND key value(如果key存在且所在值为string,追加value)


MemCache
数据存在内存
安装：http://blog.csdn.net/barrydiu/article/details/3936270
设置主从服务器：http://www.cnblogs.com/yuanermen/archive/2011/05/19/2051153.html


mongodb-python
from bson.objectid import ObjectId
db.user.insert_one({})
db.user.delete_one({u"_id": ObjectId(uid)})
db.order.update_one({"_id": ObjectId("")}, {$set: {"extension.0.0.remark":"first"}});
db.user.find_one({u"_id": ObjectId(uid)})
db.user.find({}).skip(5).limit(5)
.sort([("createdAt", -1)]).limit(1)
{_id: {$gt: ObjectId(uid)}}替代skip
db.collection.aggregate({"$unwind":"$transactions"}, {"$match":{"transactions.payload": {"$in": [300]}}},  {"$group": {"_id": "$_id", "transactions":{'$push': "$transactions"}}})  # 数组按条件筛选，文档被拆分
db.collection.aggregate([{"$match": {"createdAt": {"$gt": 123}}},
                         {"$group": {"_id": "$phone", "count": {"$sum": 1}}},
                         {"$match": {"count": {"$gt": 123}}}])
randint(0,2) NumberInt(_rand()*10%3)
{"new_name": {"$toString": "$_id"}}
{"new_name": {"$convert": {"input": "$_id", "to": "objectId", "onError": "Cannot $convert to objectId"}}
db.fetch.find().forEach(
  function(x){
      if(typeof x.res === "string" &&  JSON.parse(x.res)){
      db.fetch.update({"_id": x._id},
        {"$set":{"res": JSON.parse(x.res), "res_bak":x.res}}
      )
      }
  });
db.fetch.find().forEach(
  function(x){
    db.fetch.update({"_id": x._id, "path": ""},
      {"$set":{"ext.name": x.req.name, "ext.idCard": x.req.idCard}}
    )
  });
#  mongo关联查询
db.order.aggregate([{"$match":{"extension.from.name": {"$eq": ""}}}, {"$lookup":{"from":"suborder", "let":{"order_id":{"$toString":"$_id"}}, "pipeline":[{"$match":{"$expr":{"$and":[{"$eq":["$superId","$$order_id"]}]}}}], "as":"suborder"}}, {"$project": {"createdBy": 0, "suborder.updatedAt":0} }]);
#  mongo数组取最后一个
db.getCollection("workorder").aggregate({$project:{
"extension.type": 1,
"createdAt": 1,
"timeline":{“$slice”:["$extension.timeline", -1]}}})
# mongo 数组更新
db.getCollection("workorder").updateMany({"_id": ObjectId(id), f"extension.mission.data.{i}.header": {"$exists": True}}, {"$set": {f"extension.mission.data.{i}.$.isCompleted": 1}})
#  mongo比值为查询条件（细化字符比较$strcasecmp）,差$subtract,和$add,积$multiply,除$divide,余$mod
db.getCollection("order").aggregate([
    {
        "$match": {
						"createdAt": {"$gte": 1569859200, "$lt": 1582732800}
        }
    },
    {
        "$project": {
            "createdAt": 1,
            "cmpValue": {
                "$cmp": ["$extension.grant.confirmedAt", "$createdAt"]
            }
        }
    },
    {
        "$match": {
            "cmpValue": 1
        },
    }
])
# 字典转为mongodb.连接格式
def dict_recursion(prefix, params):  
    if isinstance(params, dict):
        dict_rst = {}
        for key, value in params.items():
            if not isinstance(value, dict) or (isinstance(value, dict) and value and list(value.keys())[0].startswith("$")):
                dict_rst[prefix + key] = value
            else:
                dict_rst_lower = dict_recursion(prefix + key + ".", value)
                dict_rst.update(dict_rst_lower)
        return dict_rst
    else:
        return {}
add index db.collection.ensureIndex({field.subfield: 1}, {background: 1})
db.getCollection("").distinct("field", {"key" : "value"})
db.getCollection('').find({"field": {"$in":db.getCollection('').aggregate(
          {$match: {}},
　　　　　　{
　　　　　　　　$group:{_id:"$field",
                    count:{$sum:1}
                    }
　　　　　　},
          {$match: {count:{$gt:1}}},
          {
　　　　　　　　$sort:{count:1}
          }
　　　　　　).map(function(el) { return el._id })}})
db.grantRolesToUser("test", [{role: "readWrite", db: "cer_test"}])
db.revokeRolesFromUser("root", [{role: "root", db: "admin"}])
