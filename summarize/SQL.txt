#SQL增删改查语句：
insert_sql = "INSERT INTO _ (, , , , , , ) VALUES ('" +  + "','" ++ "','" +  + "','" +  + "','" +  + "','" + + "','" +  + "') where not exists(select id from member where loginName = )"
delete_sql = "DELETE FROM _ WHERE _='" + i + "'"
update_sql = "UPDATE _ SET _='" +  + "' WHERE _='" +  + "'"
select_sql = "SELECT * FROM _ WHERE _='" + i + "'ORDER BY _ DESC LIMIT 1"
增删改查
cur.execute(insert_sql)
conn_yuqing.commit()
查read_sql()，read_sql_query()只能用于查询
app_management = pd.read_sql(select_sql, conn)
查询某字段非重复记录(DISTINCT必须放字段最前)
SELECT DISTINCT 字段 FROM 表
如果以某个字段去重并查出所有字段，可以函数*, GROUP_CONCAT(DISTINCT 字段)或COUNT()
查询某字段重复记录
SELECT * FROM 表 WHERE 字段 IN (SELECT 字段 FROM 表 GROUP BY 字段 HAVING COUNT(字段) > 1) WHERE type LIKE '%type%' and type NOT REGEXP '新|D'
时间戳和datetime都可的比较用> '2017-08-25 10:02:43' 查询时可用DATE_FORMAT(mydate,'%Y-%m-%d %H:%i:%s')
替换空格和tab char(9),\n char(10),\r\n char(13)
update gongshang.comp_invest_info_year_report set name=replace(name, ' ', '');
#update gongshang.comp_invest_info_year_report set name=replace(name, char(9), '');
拼接
数字直接用+
字符串（MySQL CONCAT, SQLite ||）
name=CONCAT(name,'end')
name=CONCAT_WS('.',cname,'end') #用点来连接
GROUP_CONCAT(, ';')分组后连接
转换浮点
CAST(type AS DECIMAL(8, 8)) AS type [int varchar]
统计某个字符串len(replace(column,'-','--'))-len(column)
case when exp then res0[||res01||res02] else res1[res11||res12] end as my_var
case中可以用select语句加括号，但结果需聚合为一个值，用连接或数组

Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。
Hash索引弊端：
（1）Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。
由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。
（2）Hash 索引无法被用来避免数据的排序操作。
由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；
（3）Hash 索引不能利用部分索引键查询。
对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。
（4）Hash 索引在任何时候都不能避免表扫描。
前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。
（5）Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。
对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下

内连接（等值，非等值）
=
隐式SELECT O.ID,O.ORDER_NUMBER,C.ID,C.NAME FROM CUSTOMERS C,ORDERS O WHERE C.ID=O.CUSTOMER_ID;
显示SELECT O.ID,O.ORDER_NUMBER,C.ID,C.NAME FROM CUSTOMERS C INNER JOIN ORDERS O ON C.ID=O.CUSTOMER_ID;
>、>=、<=、<、!>、!<和<>
隐式SELECT O.ID,O.ORDER_NUMBER,C.ID,C.NAME FROM CUSTOMERS C,ORDERS O WHERE C.ID>O.CUSTOMER_ID;
显示SELECT O.ID,O.ORDER_NUMBER,C.ID,C.NAME FROM CUSTOMERS C INNER JOIN ORDERS O ON C.ID>O.CUSTOMER_ID;

外连接（左，右，全）
LEFT OUTER JOIN
SELECT O.ID,O.ORDER_NUMBER,O.CUSTOMER_ID,C.ID,C.NAME FROM ORDERS O LEFT OUTER JOIN CUSTOMERS C ON C.ID=O.CUSTOMER_ID;
RIGHT OUTER JOIN
SELECT O.ID,O.ORDER_NUMBER,O.CUSTOMER_ID,C.ID,C.NAME FROM ORDERS O RIGHT OUTER JOIN CUSTOMERS C ON C.ID=O.CUSTOMER_ID;
FULL OUTER JOIN(MySQL不支持全外连接,可通过UNION)
SELECT O.ID,O.ORDER_NUMBER,O.CUSTOMER_ID,C.ID,C.NAME FROM ORDERS O FULL OUTER JOIN CUSTOMERS C ON C.ID=O.CUSTOMER_ID;
等价
SELECT O.ID,O.ORDER_NUMBER,O.CUSTOMER_ID,C.ID,C.NAME FROM ORDERS O LEFT OUTER JOIN CUSTOMERS C ON C.ID=O.CUSTOMER_ID
UNION（注：UNION去重，UNION ALL不去重）
SELECT O.ID,O.ORDER_NUMBER,O.CUSTOMER_ID,C.ID,C.NAME FROM ORDERS O RIGHT OUTER JOIN CUSTOMERS C ON C.ID=O.CUSTOMER_ID;

交叉连接（后只能用WHERE,不能ON）
隐式SELECT O.ID,O.ORDER_NUMBER,C.ID,C.NAME FROM ORDERS O,CUSTOMERS C WHERE O.ID=1;(,等价CROSS JOIN等价INNER JOIN)
显示SELECT O.ID,O.ORDER_NUMBER,C.ID,C.NAME FROM ORDERS O CROSS JOIN CUSTOMERS C WHERE O.ID=1;

自然连接
自然等值连接是特殊的等值连接，相比等值连接只能相同属性连接，去除重复列
不允许使用ON语句，不允许指定显示列。内外连接均可指定自然连接
SELECT * FROM ORDERS O NATURAL INNER JOIN CUSTOMERS C;
SELECT * FROM ORDERS O NATURAL LEFT OUTER JOIN CUSTOMERS C;
SELECT * FROM ORDERS O NATURAL RIGHT OUTER JOIN CUSTOMERS C;
SELECT * FROM ORDERS O NATURAL FULL OUTER JOIN CUSTOMERS C;

ON条件：是过滤两个链接表笛卡尔积形成中间表的约束条件。
WHERE条件：在有ON条件的SELECT语句中是过滤中间表的约束条件。在没有ON的单表查询中，是限制物理表或者中间查询结果返回记录的约束。在两表或多表连接中是限制连接形成最终中间表的返回结果的约束。
从这里可以看出，将WHERE条件移入ON后面是不恰当的。推荐的做法是：ON只进行连接操作，WHERE只过滤中间表的记录。
http://www.cnblogs.com/fnlingnzb-learner/p/6343828.html

DROP,GRANT,OPTION,REFERENCES,ALTER,DELETE,INDEX,INSERT,SELECT,UPDATE,CREATE,VIEW,SHOW,VIEW,ALTER,ROUTINE,CREATE,ROUTINE,EXECUTE,FILE,CREATE,TEMPORARY,TABLES,LOCK,TABLES,CREATE,USER,PROCESS,
EXCEPT 返回两个结果集的差（即从左查询中返回右查询没有找到的所有非重复值）。
INTERSECT 返回 两个结果集的交集（即两个查询都返回的所有非重复值）。
UNION返回两个结果集的并集。
GROUP BY通过分组再进行数据的处理，GROUP BY ALL在存在WHERE的情况下不答WHERE条件的同样显示但值为0或null
SUBSTR(字段，起始位置下标1开始，长度参数可省)
PATINDEX('%+%)计算字符索引
convert(numeric(长度,小数长度),isnull(字段,0))转化为浮点型
CAST(字段 AS DECIMAL)
insert into tb(col1,col2) select col1,col2 from tb另一表查出插入新表不需要values
GROUP BY以某个或多个字段进行分组，用聚合函数进行统计，若不用聚合函数将取每组第一条纪录,若想某列合并单行GROUP_CONCAT(字段  separator '-')
datetime时间差mysql:TIMESTAMPDIFF(SECOND, start_time_date, end_time_date) presto:date_diff('second',min(time_date),max(time_date))
mysql:整型除整型结果为浮点型，presto:整型除整型为整型
OLTP与OLAP
!=不能与NULL比较(需IS),因此!=不能删除出非NULL，既有值又有NULL时筛选不等于某值时((info != '值' OR info is NULL))
ON DUPLICATE KEY UPDATE根据主键或索引判别记录是否存在，存在可更新自定义字段，功能类似REPLACE INTO(先删再插效率略低)
如果需要判别条件，避免后面不需要的耗时查询时，可以将条件放于紧跟where后，以便提前终止
INSERT IGNORE INTO插入存在则忽略
REPLACE INTO根据主键及索引判断存在替换，不存在则插入，返回影响的行数



权限
grant all privileges on test.* to 'jack'@'192.168.0.%' identified by "jack" with grant option;
flush privileges;  # 刷新权限
show grants  for 'jack'@'%';  # 查询权限
revoke delete on *.* from 'jack'@'localhost';  # 回收权限
select host,user,password from user;
drop user 'jack'@'localhost';  # 删除用户
rename user 'jack'@'%' to 'jim'@'%';  # 重命名
SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123456');  # 修改密码
all privileges所有权限
on指定库表,test.*为test库下的所有表
%任意
indentified by为指定用户登录密码
with grant option为赋予用户授权给其它用户
DROP,GRANT,OPTION,REFERENCES,ALTER,DELETE,INDEX,INSERT,SELECT,UPDATE,CREATE,VIEW,SHOW,VIEW,ALTER,ROUTINE,CREATE,ROUTINE,EXECUTE,FILE,CREATE,TEMPORARY,TABLES,LOCK,TABLES,CREATE,USER,PROCESS
创建表时，表名字段不用加引号

SQLite IDE可使用:
SQLite Administrator(http://sqliteadmin.orbmu2k.de/)
SQLite Developer(http://www.sqlitedeveloper.com/download)

锁(show status like 'table%';)
表级锁(MyISAM和MEMORY存储引擎)，分表共享读锁、独占写锁。
页级锁(BDB存储引擎但也支持表级锁)
行级锁(InnoDB但也支持表级锁, 分布式存储引擎NDBCluster)
SET LOW_PRIORITY_UPDATES=1使该连接读比写的优先级高


sql server：
UPDATE [dbo].[t_test_drug] SET [t_test_drug].field1 = [t_test_drug].field1 + '1'  WHERE orderId = 1
设置id字段自增长
alter table calculate_method drop column id
alter table calculate_method add id int identity(1,1)

删除重复数据，仅保留一条：
DELETE FROM douyin.commerce_compass_live_data WHERE id NOT IN (
SELECT t.min_id FROM (
  SELECT MIN(id) as min_id FROM douyin.commerce_compass_live_data where live_room_id IS not null GROUP BY live_room_id
) AS t
) 

删除数据后保持ID连续
SET @max_id = (SELECT MAX(id) + 1 FROM `dbxg_live_result_tb` );
SET @sql = CONCAT('ALTER TABLE `dbxg_live_result_tb` AUTO_INCREMENT = ', @max_id);
PREPARE st FROM @sql;
EXECUTE st;
